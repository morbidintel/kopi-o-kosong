// Copyright Gamelogic (c) http://www.gamelogic.co.za

using System;
using System.Collections.Generic;
using System.Linq;
using Gamelogic.Extensions.Internal;
using UnityEngine;
using Random = System.Random;

namespace Gamelogic.Extensions.Algorithms
{
	/// <summary>
	/// A generator can produce a infinite sequence of objects.
	/// </summary>
	/// <seealso cref="IGenerator{TResult}"/>
	[Version(2)]
	public interface IGenerator
	{
		/// <summary>
		/// Gets the element last generated by this generator. It is always (in theory) valid to query this property.
		/// When called right after the generator is constructed (before calls to move next), 
		/// it gives the first element of this generator.
		/// 
		/// In practice, it is possible for a generator to overflow. 
		/// </summary>
		object Current { get; }

		/// <summary>
		/// Generates the next element.
		/// </summary>
		void MoveNext();

		/// <summary>
		/// Clones the generator and returns the clone in a restarted state.
		/// </summary>
		IGenerator CloneAndRestart();
	}

	/// <summary>
	/// All generic generators implement this interface.
	/// </summary>
	/// <typeparam name="TResult">The type of the elements the generator generates.</typeparam>
	/// <remarks> 
	/// To correctly implement this interface:
	/// <list type="">
	/// <item>A call to Current immediately after constructing the class 
	/// must give the first element of the generator. This is in contrast to 
	/// IEnumerator, where a call to MoveNext must be made first.</item>
	/// <item>Calls to Current must always give a valid element, no matter
	/// how many times MoveNext has been called. Generators never end. </item>
	/// <item>Calls to Current must always give the same value until the next 
	/// call to MoveNext is made.</item>
	/// <item>MoveNext must make all computations to generate the next element. In general, a private 
	/// variable holds the current value, is calculated in this method, and returned by Current. </item>
	/// <item>Generators that are built from other generators must CloneAndRestart the generators and store 
	/// the clones. This ensures calls to MoveNext in this generator won't affect elements generated by 
	/// a generated passed in as an argument in the constructor.</item>
	/// <item>The generator must store all information needed to be able to 
	/// produce an equivalent generator in CloneAndRestart. Generally, generators are equivalent when 
	/// they generate the same elements (in the same order). There are some exceptions, for example,
	/// unseeded random number generators. It is not necessary to 
	/// CloneAndRestart generators stored internally when creating a new instance of the generator, since
	/// that should be done in the constructor. </item>
	/// </list>
	///  
	/// </remarks>
	[Version(2)]
	public interface IGenerator<out TResult> : IGenerator
	{
		/// <summary>
		/// Gets the element last generated by this generator.
		/// </summary>
		new TResult Current { get; }

		/// <summary>
		/// Clones the generator and returns the clone in a restarted state.
		/// </summary>
		new IGenerator<TResult> CloneAndRestart();
	}

	/// <summary>
	/// Contains static methods for creating generators, and extension methods to 
	/// create generators from existing ones.
	/// </summary>
	/// <remarks>A generator is a class that generates data on demand. In this implementation, 
	/// generators implement the IGenerator interface, and through an extension method supports
	/// a Next method that returns an element every time it is called.
	/// 
	/// Generators are infinite.
	/// 
	/// Many methods make methods from existing generators. The existing generators are always
	/// cloned, so no derived generator will call the Next or MoveNext methods of an existing generator.
	/// Clones are always returned in the restarted state. 
	/// 
	/// Although Generators have almost the same interface as IEnumerator, there are some differences. Generators 
	/// are always in a "valid" state, so calls to Current will always return a valid result, there is no "before first" and "after last" states. 
	/// 
	/// You can also implement your own generators. There are two ways to do this. The first
	/// is to simply use the static methods provided; they allow you to make new generators
	/// by manipulating existing ones.
	/// 
	/// The second way is appropriate for more complicated situations, and that is to define your own class
	/// that implements the IGenerator&lt;T&gt; interface. <see cref="IGenerator{TResult}"/>
	/// </remarks>
	[Version(2)]
	public static partial class Generator
	{
		#region Private Fields
		private static readonly Random SeedGenerator = new Random();
		#endregion

		#region API 
		/// <summary>
		/// Returns the next element of the specified generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <returns>TSource.</returns>
		/// <exception cref="System.ArgumentNullException">generator</exception>
		public static TSource Next<TSource>(this IGenerator<TSource> generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			var current = generator.Current;
			
			generator.MoveNext();
			
			return current;
		}

		/// <summary>
		/// Generates the elements from the generator while the predicate applied to elements
		/// hold an return them in an enumerable. After calling this method,
		/// the next element returned by Next (or the current value of Current) will not satisfy 
		/// the predicate.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="source">The source generator.</param>
		/// <param name="predicate">The predicate.</param>
		/// <returns>A new enumerator.</returns>
		/// <example>The enumerable in the following will contain the elements 0, 1, 2, 3:
		/// <code>
		/// var list = Generator.Count(100).NextWhile(x =&gt; x &lt; 4);
		/// </code></example>
		public static IEnumerable<TSource> NextWhile<TSource>(
			this IGenerator<TSource> source, 
			Func<TSource, bool> predicate)
		{
			var list = new List<TSource>();
			while (predicate(source.Current))
			{
				list.Add(source.Next());
			}
			return list;
		}

		/// <summary>
		/// Returns a list of the next n items from the generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="count">How many items to return.</param>
		/// <returns>IEnumerable&lt;TResult&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">generator</exception>
		/// <exception cref="System.ArgumentOutOfRangeException">count;Argument must be positive.</exception>
		public static IEnumerable<TSource> Next<TSource>(this IGenerator<TSource> generator, int count)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (count <= 0) throw ArgumentNotPositiveException("count");

			var list = new List<TSource>(count);

			for (int i = 0; i < count; i++)
			{
				list.Add(generator.Next());
			}

			return list;
		}

		/// <summary>
		/// Moves the generator by a specified amount forward.
		/// </summary>
		/// <typeparam name="TSource">The type of the t source.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="count">The number of times to move the generator forward.</param>
		/// <exception cref="System.ArgumentNullException">generator</exception>
		/// <exception cref="System.ArgumentOutOfRangeException">count;Argument cannot be smaller than 0.</exception>
		public static void MoveNext<TSource>(this IGenerator<TSource> generator, int count)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (count < 0) throw ArgumentNegativeException("count");
			
			for (int i = 0; i < count; i++)
			{
				generator.MoveNext();
			}
		}

		/// <summary>
		/// Makes a generator that generates a the same item each time.
		/// </summary>
		/// <typeparam name="TSource">The type of the item to generate.</typeparam>
		/// <param name="item">The item to generate.</param>
		public static IGenerator<TSource> Constant<TSource>(TSource item)
		{
			return new ConstantGenerator<TSource>(item);
		}

		/// <summary>
		/// Makes a new generator from a generator function.
		/// </summary>
		/// <typeparam name="TResult">The type of elements to generate.</typeparam>
		/// <param name="generator">The generator function that will be 
		/// called to generate new elements.</param>
		/// <exception cref="System.ArgumentNullException">generator</exception>
		public static IGenerator<TResult> FromFunc<TResult>(Func<TResult> generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			return new FuncGenerator<TResult>(generator);
		}

		/// <summary>
		/// Makes a generator which generates items that are transformed, generated from a given generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <typeparam name="TResult">The type of the result generator.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="selector">The function used to transform elements of the source generator.</param>
		/// <returns>IGenerator&lt;TResult&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">
		/// generator
		/// or
		/// selector
		/// </exception>
		public static IGenerator<TResult> Select<TSource, TResult>(
			this IGenerator<TSource> generator, 
			Func<TSource, TResult> selector)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (selector == null) throw ArgumentNullException("selector");

			return new SelectGenerator<TSource,TResult>(generator, selector);
		}

		/// <summary>
		/// Makes a new generator by transforming the elements of a given 
		/// float generator using a response curve.
		/// </summary>
		/// <typeparam name="TResult">The type of elements this generator will generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="selector">The selector function, used to transform floats to elements.</param>
		/// <returns>IGenerator&lt;TResult&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">
		/// <c>generator</c> or <c>selector</c> is <b>null</b>
		/// </exception>
		public static IGenerator<TResult> Select<TResult>(
			this IGenerator<float> generator, 
			ResponseCurveBase<TResult> selector)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (selector == null) throw ArgumentNullException("selector");

			return generator.Select(x => selector[x]);
		}

		/// <summary>
		/// For each item in the source generator, a list of items is generated, but the items are generated
		/// one by one (and not as a list of items).
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <typeparam name="TResult">The type of the result generator.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="selector">The function that transform elements of the source generator to a list
		/// of items.</param>
		/// <returns>IGenerator&lt;TResult&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">
		/// generator
		/// or
		/// selector
		/// </exception>
		public static IGenerator<TResult> SelectMany<TSource, TResult>(
			this IGenerator<TSource> generator, 
			Func<TSource, IEnumerable<TResult>> selector)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (selector == null) throw ArgumentNullException("selector");

			return new SelectManyGenerator<TSource,TResult>(generator, selector);
		}

		/// <summary>
		/// Makes a generator that will only generate elements that pass the predicate.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="predicate">The predicate.</param>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		public static IGenerator<TSource> Where<TSource>(this IGenerator<TSource> generator, Func<TSource, bool> predicate)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (predicate == null) throw ArgumentNullException("predicate");

			var selector = generator.Select(predicate);

			return new WhereGenerator<TSource>(generator, selector);
		}

		/// <summary>
		/// Makes a generator that will only generate elements that pass the predicate generated by the predicate generator.
		/// </summary>
		public static IGenerator<TSource> Where<TSource>(this IGenerator<TSource> generator, IGenerator<bool> predicateGenerator)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (predicateGenerator == null) throw ArgumentNullException("selector");

			return new WhereGenerator<TSource>(generator, predicateGenerator);
		}

		/// <summary>
		/// Makes a generator that will only generate elements that pass the predicate. If the source elements does not provide
		/// elements that pass the predicate for the given number of maximum iterations, an exception is thrown. 
		/// This is to prevent a stalling the generator forever.
		/// </summary>
		public static IGenerator<T> Where<T>(this IGenerator<T> generator, Func<T, bool> predicate, int maxIterations)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (predicate == null) throw ArgumentNullException("predicate");

			var selector = generator.Select(predicate);

			return new WhereGenerator<T>(generator, selector, maxIterations);
		}

		/// <summary>
		/// Makes a generator that will only generate elements that pass the predicate generated by
		/// the predicate generator. If the source elements does not provide
		/// elements that pass the predicate for the given number of maximum iterations, an exception is thrown. 
		/// This is to prevent a stalling the generator forever.
		/// </summary>
		public static IGenerator<T> Where<T>(this IGenerator<T> generator, IGenerator<bool> predicateGenerator, int maxIterations)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (predicateGenerator == null) throw ArgumentNullException("selector");

			return new WhereGenerator<T>(generator, predicateGenerator, maxIterations);
		}

		/// <summary>
		/// A generator that generates the elements of the source generator, but applies a log function to each element as it is generated.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="log">The log.</param>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		/// <remarks>This generator is useful for debugging, to inspect the results of a internal generator.
		/// It should not be used for other purposes. (Generators should generally not have side effects).</remarks>
		/// <example>
		/// <code>
		/// var generator = Generator.Count(4).Log(x => Debug.Log(x.ToString())).Select(x => 2*x);
		/// </code></example>
		public static IGenerator<TSource> Log<TSource>(
			this IGenerator<TSource> generator, 
			Action<TSource> log)
		{
			return Select(generator, x =>
			{
				log(x);

				return x;
			});
		} 


		/// <summary>
		/// A generator that generates the elements of the source generator, but sends the generated element to the Unity Console.
		/// </summary>
		/// <param name="generator">The base generator.</param>
		/// <typeparam name="TSource">The type of the generator's items.</typeparam>
		public static IGenerator<TSource> Log<TSource>(
			this IGenerator<TSource> generator)
		{
			return Log(generator, x => Debug.Log(generator.GetType().Name + ": " + x.ToString()));
		}

		/// <summary>
		/// Only generates an item if the window of the item passes the predicate.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="generator">The generator.</param>
		/// <param name="windowSize">Size of the window.</param>
		/// <param name="predicate">The predicate.</param>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">
		/// generator
		/// or
		/// predicate
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">windowSize;Argument must be positive.</exception>
		/// <remarks>The window of an item is the element and a number of elements after the
		/// element (together, the number of elements is <c>windowSize</c>.</remarks>
		public static IGenerator<TSource> WhereWindow<TSource>(
			this IGenerator<TSource> generator, 
			int windowSize, 
			Func<TSource[], bool> predicate)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (predicate == null) throw ArgumentNullException("predicate");
			if (windowSize <= 0) throw ArgumentNotPositiveException("windowSize");
			
			return generator.Window(windowSize)
				.Where(predicate)
				.Select(w => w[0]);
		}

		/// <summary>
		/// Makes a generator that returns iterations of the specified initial element.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="initialElement">The initial element.</param>
		/// <param name="iterator">The iteration function.</param>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">iterator</exception>
		/// <remarks>If the iteration function is <c>f</c> and the initial element is <c>x</c>, then
		/// the result generator wil generate <c>x, f(x), f(f(x)), f(f(f(x))), ...</c></remarks>
		public static IGenerator<TSource> Iterate<TSource>(
			TSource initialElement, 
			Func<TSource, TSource> iterator)
		{
			if (iterator == null) throw ArgumentNullException("iterator");

			return new IterateGenerator<TSource>(initialElement, iterator);
		}

		/// <summary>
		/// Applies a function on the last element to produce the next element. The function
		/// takes twp parameters; the second parameter is supplied by a generator.
		/// </summary>
		public static IGenerator<TSource> Iterate<TSource, TSource2>(
			TSource initialElement,
			IGenerator<TSource2> parm2, 
			Func<TSource, TSource2, TSource> iterator)
		{
			if (iterator == null) throw ArgumentNullException("iterator");

			return new IterateGenerator1<TSource, TSource2>(initialElement, parm2, iterator);
		}

		/// <summary>
		/// Makes a generator that uses an iterator function to generate elements.
		/// </summary>
		/// <typeparam name="TSource">The type of the t source.</typeparam>
		/// <param name="initialElement0">The first element to generate.</param>
		/// <param name="initialElement1">The second element to generate.</param>
		/// <param name="iterator">The iterator function.</param>
		/// <exception cref="System.ArgumentNullException">iterator</exception>
		/// <remarks>The iterator function is applied the last two items generated to produce the next one.
		/// The first two elements are provided by the caller.
		/// For example, <code>Iterate(0, 1, (x, y) => x + y);</code> make a generator that produces the Fibonacci numbers.
		/// </remarks>
		public static IGenerator<TSource> Iterate<TSource>(
			TSource initialElement0,
			TSource initialElement1,
			Func<TSource, TSource, TSource> iterator)
		{
			if (iterator == null) throw ArgumentNullException("iterator");

			return new IterateNGenerator<TSource>(
				new[] {initialElement0, initialElement1}, 
				list => iterator(list[0], list[1]));
		}

		/// <summary>
		/// Makes a generator that uses an iterator function to generate elements.
		/// </summary>
		/// <typeparam name="TSource">The type of the t source.</typeparam>
		/// <param name="initialElement0">The first element to generate.</param>
		/// <param name="initialElement1">The second element to generate.</param>
		/// <param name="initialElement2">The third element to generate.</param>
		/// <param name="iterator">The iterator function.</param>
		/// <exception cref="System.ArgumentNullException">iterator</exception>
		/// <remarks>The iterator function is applied the last three items generated to produce the next one.
		/// The first three elements are provided by the caller.
		/// For example, <code>Iterate(0, 0, 1, (x, y, z) => x + y + z);</code> make a generator that produces the Tribonacci numbers.
		/// </remarks>
		public static IGenerator<TSource> Iterate<TSource>(
			TSource initialElement0,
			TSource initialElement1,
			TSource initialElement2,
			Func<TSource, TSource, TSource, TSource> iterator)
		{
			if (iterator == null) throw ArgumentNullException("iterator");

			return new IterateNGenerator<TSource>(
				new[] { initialElement0, initialElement1, initialElement2},
				list => iterator(list[0], list[1], list[2]));
		}

		/// <summary>
		/// Makes a generator that uses an iterator function to generate elements.
		/// </summary>
		/// <typeparam name="TSource">The type of the t source.</typeparam>
		/// <param name="initialElement0">The first element to generate.</param>
		/// <param name="initialElement1">The second element to generate.</param>
		/// <param name="initialElement2">The third element to generate.</param>
		/// <param name="initialElement3">The fourth element to generate.</param>
		/// <param name="iterator">The iterator function.</param>
		/// <exception cref="System.ArgumentNullException">iterator</exception>
		/// <remarks>The iterator function is applied the last four items generated to produce the next one.
		/// The first four elements are provided by the caller.
		/// For example, <code>Iterate(0, 0, 0, 1, (x, y, z, w) => x + y + w + z);</code> make a generator that produces the Tetranacci numbers.
		/// </remarks>
		public static IGenerator<TSource> Iterate<TSource>(
			TSource initialElement0,
			TSource initialElement1,
			TSource initialElement2,
			TSource initialElement3,
			Func<TSource, TSource, TSource, TSource, TSource> iterator)
		{
			if (iterator == null) throw ArgumentNullException("iterator");

			return new IterateNGenerator<TSource>(
				new[] { initialElement0, initialElement1 },
				list => iterator(list[0], list[1], list[2], list[3]));
		}

		/// <summary>
		/// Makes a generator that uses an iterator function to generate elements.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="initialElements">The initial elements.</param>
		/// <param name="iterator">The iterator function.</param>
		/// <exception cref="System.ArgumentNullException">iterator</exception>
		/// <remarks>Uses the last n elements to generate the next one, where n is the same
		/// number of elements as is provided initially.</remarks>
		public static IGenerator<TSource> Iterate<TSource>(
			IEnumerable<TSource> initialElements,
			Func<IList<TSource>, TSource> iterator)
		{
			if (iterator == null) throw ArgumentNullException("iterator");

			return new IterateNGenerator<TSource>(
				initialElements,
				iterator);
		}
		
		/// <summary>
		/// Makes a generator that generates groups of items from the source generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="groupSizeGenerator">The generator used to determine the size of the groups to return.</param>
		/// <returns>IGenerator&lt;IEnumerable&lt;TSource&gt;&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">generator</exception>
		/// <exception cref="System.ArgumentOutOfRangeException">groupSizeGenerator;Argument must be positive.</exception>
		public static IGenerator<IList<TSource>> Group<TSource>(
			this IGenerator<TSource> generator, 
			IGenerator<int> groupSizeGenerator)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (groupSizeGenerator == null) throw ArgumentNullException("groupSizeGenerator");
			
			return new GroupGenerator<TSource>(generator, groupSizeGenerator);
		}

		/// <summary>
		/// Makes a generator that returns groups of elements from the source generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="groupSize">The size of the groups.</param>
		/// <returns>IGenerator&lt;IEnumerable&lt;TSource&gt;&gt;.</returns>
		/// <exception cref="System.ArgumentNullException">generator</exception>
		/// <exception cref="System.ArgumentOutOfRangeException">groupSize;Argument must be positive.</exception>
		/// <remarks>For example, if the source generator generates 0, 1, 2, 3, ... and the group size is 2
		/// then the result generator will return groups (0, 1), (2, 3), ...</remarks>
		public static IGenerator<IList<TSource>> Group<TSource>(
			this IGenerator<TSource> generator, 
			int groupSize)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (groupSize <= 0) throw ArgumentNotPositiveException("groupSize");
			
			return generator.Group(Constant(groupSize));
		}

		/// <summary>
		/// Makes a generator that repeats elements of the given list over and over.
		/// </summary>
		/// <typeparam name="TSource">The type of elements in the given list and the type of 
		/// elements that will be generated.</typeparam>
		/// <param name="list">The list from which elements are generated.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException">list</exception>
		public static IGenerator<TSource> Repeat<TSource>(IEnumerable<TSource> list)
		{
			if (list == null) throw ArgumentNullException("list");

			return new RepeatGenerator<TSource>(list);
		}

		/// <summary>
		/// Makes a new generator that will repeat each of the given generators 
		/// elements a number of times.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="repeatCountGenerator">A generator used to get the number of times each element will be generated.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c></exception>
		/// <exception cref="System.ArgumentNullException"><c>repeatCountGenerator</c> is <b>null</b>.</exception>
		public static IGenerator<TSource> RepeatEach<TSource>(
			this IGenerator<TSource> generator, 
			IGenerator<int> repeatCountGenerator)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (repeatCountGenerator == null) throw ArgumentNullException("repeatCountGenerator");

			return new RepeatEachGenerator<TSource>(generator, repeatCountGenerator);
		}

		/// <summary>
		/// Makes a new generator that will repeat each of the given generators 
		/// elements a number of times.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="repeatCount">The number of times each element will be generated.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is <b>null</b></exception>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>repeatCount</c> is not positive.</exception>
		public static IGenerator<TSource> RepeatEach<TSource>(
			this IGenerator<TSource> generator, 
			int repeatCount)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (repeatCount <= 0) throw ArgumentNotPositiveException("repeatCount");
			
			return new RepeatEachGenerator<TSource>(generator, Constant(repeatCount));
		}

		/// <summary>
		/// Makes a generator that generates consecutive integers starting from zero up to a limit, and repeats the cycle.
		/// </summary>
		/// <param name="upperLimitExcluded">The upper limit (excluded).</param>
		/// <returns>A new generator</returns>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>upperLimitExcluded</c> is not positive.</exception>
		public static IGenerator<int> Count(int upperLimitExcluded)
		{
			if (upperLimitExcluded <= 0) throw ArgumentNotPositiveException("upperLimitExcluded");
			
			return new CountGenerator(upperLimitExcluded);
		}

		/// <summary>
		/// Makes a generator that produces evenly spaced floats from 0 to 1, both limits included, and repeats the result.
		/// </summary>
		/// <param name="sampleCount">The number of samples per cycle.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>sampleCount</c>is not bigger than 1.</exception>
		public static IGenerator<float> ClosedSawTooth(int sampleCount)
		{
			if (sampleCount <= 1) throw ArgumentNotBiggerThan(1, "sampleCount");
			
			return Count(sampleCount)
				.Select(i => i/(sampleCount - 1f));
		}

		/// <summary>
		/// Makes a generator that produces evenly spaced floats from 0 (included) 
		/// to 1 (excluded), and repeats the result.
		/// </summary>
		/// <param name="sampleCount">The number of samples per cycle.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>sampleCount</c>is not positive.</exception>
		public static IGenerator<float> OpenSawTooth(int sampleCount)
		{
			if (sampleCount <= 0) throw ArgumentNotPositiveException("sampleCount");
			
			return Count(sampleCount)
				.Select(i => i / (float) sampleCount);
		}

		/// <summary>
		/// Makes a generator that produces evenly spaced floats from 0 (included) 
		/// to 1 (excluded), and repeats the result (but with the number of samples 
		/// each time given by a generator).
		/// </summary>
		/// <param name="sampleCount">The number of samples per cycle.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>sampleCount</c>is not positive.</exception>
		public static IGenerator<float> OpenSawTooth(IGenerator<int> sampleCount)
		{
			if (sampleCount == null) throw ArgumentNullException("sampleCount");

			var ramps = sampleCount.SelectMany(x => Enumerable.Range(0, x)); //0 1 2 0 1 2 3 4
			var divisor = RepeatEach(sampleCount, sampleCount); //3 3 3 5 5 5 5 5

			return Combine(ramps, divisor, (r, d) => r/(float) d);
		}

		/// <summary>
		/// Makes a generator that generates integers uniformly distributed between 0 (included) and
		/// the specified limit (excluded).
		/// </summary>
		/// <param name="upperLimitExcluded">The upper limit (excluded).</param>
		/// <returns>IGenerator&lt;System.Int32&gt;.</returns>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>upperLimitExcluded</c>is not positive.</exception>
		public static IGenerator<int> UniformRandomInt(int upperLimitExcluded)
		{
			if (upperLimitExcluded <= 0) throw ArgumentNotPositiveException("upperLimitExcluded");
			
			return new UniformRandomIntGenerator(upperLimitExcluded);
		}

		/// <summary>
		/// Makes a generator hat generates integers uniformly distributed between 0 (included) and
		/// the specified limit (excluded).
		/// </summary>
		/// <param name="upperLimitExcluded">The upper limit (excluded).</param>
		/// <param name="seed">The seed to use for the random number generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentOutOfRangeException"><c>upperLimitExcluded</c>is not positive.</exception>
		public static IGenerator<int> UniformRandomInt(int upperLimitExcluded, int seed)
		{
			if (upperLimitExcluded <= 0) throw ArgumentNotPositiveException("upperLimitExcluded");

			return new UniformRandomIntGenerator(upperLimitExcluded, seed);
		}

		/// <summary>
		/// Generates random integers at relative frequencies provided.
		/// </summary>
		/// <param name="frequencies">The relative frequencies of each integer. If the array of frequencies has three elements, then the integers produced will be
		/// 0, 1, 2 (provided all frequencies are positive). All frequencies must be non-negative, and at 
		/// least one must be positive.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<int> FrequencyRandomInt(IEnumerable<float> frequencies)
		{
			if (frequencies == null) throw ArgumentNullException("frequencies");

			return new FrequencyIntGenerator(frequencies, UniformRandomFloat());
		}

		/// <summary>
		/// Generates random integers at relative frequencies provided.
		/// </summary>
		/// <param name="frequencies">The relative frequencies of each integer. If the array of frequencies has three elements, then the integers produced will be
		/// 0, 1, 2 (provided all frequencies are positive). All frequencies must be non-negative, and at 
		/// least one must be positive.</param>
		/// <param name="seed">A seed to use for the random number generator.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<int> FrequencyRandomInt(IEnumerable<float> frequencies, int seed)
		{
			if (frequencies == null) throw ArgumentNullException("frequencies");

			return new FrequencyIntGenerator(frequencies, UniformRandomFloat(seed));
		}

		/// <summary>
		/// Generates a Markov chain of integers from a transition table.
		/// </summary>
		/// <param name="transitionTable">The transition table to use. The value in the table 
		/// at [i][j] is the relative probability that i will be followed by j. Note that values 
		/// in a row need not add to 1, the values are normalized per row. In each row, there 
		/// must be at least one positive value. All values must be non-negative.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<int> MarkovRandomInt(float[,] transitionTable)
		{
			if (transitionTable == null) throw ArgumentNullException("transitionTable");

			return new MarkovChainIntGenerator(transitionTable, UniformRandomFloat());
		}

		/// <summary>
		/// Makes a Markov generator that starts with the given value.
		/// </summary>
		/// <see cref="MarkovRandomInt(float[,])"/>
		public static IGenerator<int> MarkovRandomIntStartsWith(float[,] transitionTable, int initialValue)
		{
			if (transitionTable == null) throw ArgumentNullException("transitionTable");

			return new MarkovChainIntGenerator(transitionTable, UniformRandomFloat(), initialValue);
		}

		/// <summary>
		/// Makes a Markov generator that starts with the given value.
		/// </summary>
		/// <see cref="MarkovRandomInt(float[,])"/>
		public static IGenerator<int> MarkovRandomIntStartsWith(float[,] transitionTable, int initialValue, int seed)
		{
			if (transitionTable == null) throw ArgumentNullException("transitionTable");

			return new MarkovChainIntGenerator(transitionTable, UniformRandomFloat(seed), initialValue);
		}

		/// <summary>
		/// Generates a Markov chain of integers from a transition table.
		/// </summary>
		/// <param name="transitionTable">The transition table to use. The value in the table 
		/// at [i][j] is the relative probability that i will be followed by j. Note that values 
		/// in a row need not add to 1, the values are normalized per row. In each row, there 
		/// must be at least one positive value. All values must be non-negative.</param>
		/// <param name="seed">The seed to use for the random number generator.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<int> MarkovRandomInt(float[,] transitionTable, int seed)
		{
			if (transitionTable == null) throw ArgumentNullException("transitionTable");

			return new MarkovChainIntGenerator(transitionTable, UniformRandomFloat(seed));
		}

		/// <summary>
		/// Makes a generator hat generates floats uniformly between 0 and 1.
		/// </summary>
		/// <returns>A new generator.</returns>
		public static IGenerator<float> UniformRandomFloat()
		{
			return new UniformRandomFloatGenerator();
		}

		/// <summary>
		/// Makes a generator that generates floats with a Gaussian distribution.
		/// </summary>
		/// <param name="mean">The mean of the distribution. Values generated will be centered around this point.</param>
		/// <param name="standardDeviation">The standard deviation of the distribution. The bigger this value, the flatter the distribution curve will be.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<float> GaussianRandomFloat(float mean, float standardDeviation)
		{
			return UniformRandomFloat()
				.Group(2)
				.SelectMany(group => BoxMullerTransform(mean, standardDeviation, group[0], group[1]));
		}

		/// <summary>
		/// Generates vectors uniformly distributed in a given rectangle.
		/// </summary>
		/// <param name="dimensions">The dimensions of the rectangle.</param>
		public static IGenerator<Vector2> UniformVector2InRect(Vector2 dimensions)
		{
			var xGenerator = UniformRandomFloat(GLRandom.GlobalRandom.Next());
			var yGenerator = UniformRandomFloat(GLRandom.GlobalRandom.Next());
			
			return Combine(xGenerator, yGenerator, (x, y) => new Vector2(x*dimensions.x, y*dimensions.y));
		}

		/// <summary>
		/// Generates vectors uniformly distributed in a given circle.
		/// </summary>
		public static IGenerator<Vector2> UniformVector2InCircle(float radius)
		{
			var xGenerator = UniformRandomFloat(GLRandom.GlobalRandom.Next());
			var yGenerator = UniformRandomFloat(GLRandom.GlobalRandom.Next());

			return 
				Combine(xGenerator, yGenerator, (x, y) => new Vector2((x - 0.5f) * 2 * radius, (y - 0.5f) * 2 * radius))
					.Where(v => v.magnitude < radius);
		}

		/// <summary>
		/// Makes a generator that generates floats uniformly between 0 and 1.
		/// </summary>
		/// <returns>A new generator.</returns>
		public static IGenerator<float> UniformRandomFloat(int seed)
		{
			return new UniformRandomFloatGenerator(seed);
		}

		/// <summary>
		/// Combines the specified generators by applying a result selector
		/// function to the elements of each generator.
		/// </summary>
		/// <typeparam name="T1">The type of elements of the first generator.</typeparam>
		/// <typeparam name="T2">The type of elements of the second generator.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the result generator.</typeparam>
		/// <param name="generator1">The first generator.</param>
		/// <param name="generator2">The second generator.</param>
		/// <param name="resultSelector">The result selector function.</param>
		/// <returns>A new generator</returns>
		/// <exception cref="System.ArgumentNullException">generator1
		/// or
		/// generator2
		/// or
		/// resultSelector</exception>
		/// <example>The following will code will add the elements of two generators to form its elements.
		/// <code>
		/// var generator1 = Generator.Count(3); //generates 0 1 2 0 1 2 0 1 2...
		/// var generator2 = Generator.Count(2); //generates 0 1 0 1 0 1 0 1 0...
		/// 
		/// var generator = Generator.Combine(generator1, generator2, (x, y) =&gt; x + y);
		///		//generates 0 2 2 1 1 3 0 2 2...
		/// </code></example>
		/// <exception cref="System.ArgumentNullException"><c>generator1</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>generator2</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>resultSelector</c> is <b>null</b>.</exception>

		public static IGenerator<TResult> Combine<T1, T2, TResult>(
			IGenerator<T1> generator1,
			IGenerator<T2> generator2, 
			Func<T1, T2, TResult> resultSelector)
		{
			if (generator1 == null) throw ArgumentNullException("generator1");
			if (generator2 == null) throw ArgumentNullException("generator2");
			if (resultSelector == null) throw ArgumentNullException("resultSelector");

			return new CombineGenerator<T1,T2,TResult>(generator1, generator2, resultSelector);
		}

		/// <summary>
		/// Combines the specified generators by applying a result selector
		/// function to the elements of each generator.
		/// </summary>
		/// <typeparam name="T1">The type of elements of the first generator.</typeparam>
		/// <typeparam name="T2">The type of elements of the second generator.</typeparam>
		/// <typeparam name="T3">The type of elements of the third generator.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the result generator.</typeparam>
		/// <param name="generator1">The first generator.</param>
		/// <param name="generator2">The second generator.</param>
		/// <param name="generator3">The third generator.</param>
		/// <param name="resultSelector">The result selector function.</param>
		/// <returns>A new generator</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator1</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>generator2</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>generator3</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>resultSelector</c> is <b>null</b>.</exception>
		public static IGenerator<TResult> Combine<T1, T2, T3, TResult>(
			IGenerator<T1> generator1,
			IGenerator<T2> generator2,
			IGenerator<T3> generator3,
			Func<T1, T2, T3, TResult> resultSelector)
		{
			if (generator1 == null) throw ArgumentNullException("generator1");
			if (generator2 == null) throw ArgumentNullException("generator2");
			if (generator3 == null) throw ArgumentNullException("generator3");
			if (resultSelector == null) throw ArgumentNullException("resultSelector");

			return new CombineGenerator<T1, T2, T3, TResult>(
				generator1, 
				generator2, 
				generator3, 
				resultSelector);
		}

		/// <summary>
		/// Combines the specified generators by applying a result selector
		/// function to the elements of each generator.
		/// </summary>
		/// <typeparam name="T1">The type of elements of the first generator.</typeparam>
		/// <typeparam name="T2">The type of elements of the second generator.</typeparam>
		/// <typeparam name="T3">The type of elements of the third generator.</typeparam>
		/// <typeparam name="T4">The type of elements of the fourth generator.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the result generator.</typeparam>
		/// <param name="generator1">The first generator.</param>
		/// <param name="generator2">The second generator.</param>
		/// <param name="generator3">The third generator.</param>
		/// <param name="generator4">The fourth generator.</param>
		/// <param name="resultSelector">The result selector function.</param>
		/// <returns>A new generator</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator1</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>generator2</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>generator3</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>generator4</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>resultSelector</c> is <b>null</b>.</exception>
		public static IGenerator<TResult> Combine<T1, T2, T3, T4, TResult>(
			IGenerator<T1> generator1,
			IGenerator<T2> generator2,
			IGenerator<T3> generator3,
			IGenerator<T4> generator4,
			Func<T1, T2, T3, T4, TResult> resultSelector)
		{
			if (generator1 == null) throw ArgumentNullException("generator1");
			if (generator2 == null) throw ArgumentNullException("generator2");
			if (generator3 == null) throw ArgumentNullException("generator3");
			if (generator4 == null) throw ArgumentNullException("generator4");
			if (resultSelector == null) throw ArgumentNullException("resultSelector");

			return new CombineGenerator<T1, T2, T3, T4, TResult>(
				generator1, 
				generator2, 
				generator3, 
				generator4, 
				resultSelector);
		}

		/// <summary>
		/// Makes a generator that combines the elements of specified generators.
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generators.</typeparam>
		/// <typeparam name="TResult">The type of elements this generator will generate.</typeparam>
		/// <param name="generators">The generators.</param>
		/// <param name="resultSelector">The result selector.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException">generators</exception>
		/// <exception cref="System.ArgumentException">Cannot contain null elements;generators</exception>
		public static IGenerator<TResult> Combine<TSource, TResult>(
			IEnumerable<IGenerator<TSource>> generators,
			Func<IList<TSource>, TResult> resultSelector)
		{
			if (generators == null) throw ArgumentNullException("generators");
			// ReSharper disable once PossibleMultipleEnumeration
			if (generators.ContainsNullElements()) throw ContainsNullElementsException("generators");
			
			// ReSharper disable once PossibleMultipleEnumeration
			return new CombineGenerator<TSource,TResult>(generators, resultSelector);
		}

		/// <summary>
		/// Makes a generator that returns random boolean values, true with the specified 
		/// probability.
		/// </summary>
		/// <param name="probability">The probability of generating $(true).</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentException"><c>probability</c> does not lie between 0 and 1 (inclusive)</exception>
		public static IGenerator<bool> RandomBoolGenerator(float probability)
		{
			if (!Between0And1(probability)) throw ArgumentNotBetween0And1Exception("probability");
			
			return UniformRandomFloat()
				.Select(x => x < probability);
		}

		/// <summary>
		/// Makes a generator that returns random boolean values, true with the specified 
		/// probability.
		/// </summary>
		/// <param name="probability">The probability of generating $(true).</param>
		/// <param name="seed">The seed to use for the random num ber generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentException"><c>probability</c> does not lie between 0 and 1 (inclusive)</exception>
		public static IGenerator<bool> RandomBoolGenerator(float probability, int seed)
		{
			if (!Between0And1(probability)) throw ArgumentNotBetween0And1Exception("probability");

			return UniformRandomFloat(seed)
				.Select(x => x < probability);
		}

		/// <summary>
		/// Makes a generator that generates a moving window of elements over a given generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="source">The source generator.</param>
		/// <param name="windowSize">Size of the window.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentOutOfRangeException">windowSize;Argument must be positive.</exception>
		/// <example>
		/// In the following example, 
		/// <code>
		/// var generator = Generator.Count(4).Window(2);
		/// </code>
		/// the generator will generate (0 1) (1 2) (2 3) (3 0) (0 1)... The window of 
		/// size 2 move one element (of the original generator) at a time.
		/// 
		/// The following is an implementation of a box blur on the given sequence:
		/// <code>
		/// public static IGenerator&lt;float&gt; BoxBlur(IGenerator&lt;float&gt; generator)
		/// {
		///		return generator.Window(3).Select(w =&gt; (w[0] + w[1] + w[2])/3f);
		/// }
		/// </code> 
		/// </example>
		public static IGenerator<TSource[]> Window<TSource>(
			this IGenerator<TSource> source, 
			int windowSize)
		{
			if (windowSize <= 0) throw ArgumentNotPositiveException("windowSize");
			
			return new WindowGenerator<TSource>(source, windowSize);
		}

		/// <summary>
		/// Makes a generator that chooses elements from a list using an index generator.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="source">The source list.</param>
		/// <param name="indexGenerator">The index generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException">
		/// list
		/// or
		/// indexGenerator
		/// </exception>
		/// <exception cref="System.ArgumentException">List must have at least one element;list</exception>
		/// <example>The following will generate "cat" "dog" "cat" "dog":
		/// <code>
		/// var generator = Generator.Choose(new[] {"cat", "dog"}, Generator.Count(2));
		/// </code>
		/// </example>
		public static IGenerator<TSource> Choose<TSource>(IList<TSource> source, 
			IGenerator<int> indexGenerator)
		{
			if (source == null) throw ArgumentNullException("source");
			if (!source.Any()) throw CollectionEmptyException("source");
			if (indexGenerator == null) throw ArgumentNullException("indexGenerator");
			
			return indexGenerator.Select(i => source[i]);
		}

		/// <summary>
		/// Makes a generator that uses an index generator to choose a generator to
		/// generate an element from.
		/// </summary>
		/// <typeparam name="TSource">The type of element to generate.</typeparam>
		/// <param name="generators">The source generators.</param>
		/// <param name="indexGenerator">The index generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException">generators
		/// or
		/// indexGenerator</exception>
		/// <exception cref="System.ArgumentException">Cannot contain null elements;generators</exception>
		/// <example>
		/// The following generator will interleave the given generators:
		/// 
		/// <code>
		/// //generators is a IEnumerable of generators
		/// var generator = Generator.Choose(generators, Generator.Count(generators.Count());</code>
		/// </example>
		public static IGenerator<TSource> Choose<TSource>(IList<IGenerator<TSource>> generators, 
			IGenerator<int> indexGenerator)
		{
			if (generators == null) throw ArgumentNullException("generators");
			if (!generators.Any()) throw CollectionEmptyException("generators");
			if (indexGenerator == null) throw ArgumentNullException("indexGenerator");

			return new ChooseGenerator<TSource>(generators, indexGenerator);
		}

		/*public static IGenerator<TSource> Choose<TSource>(IGenerator<TSource>[] generators,
			IGenerator<int> indexGenerator)
		{
			if (generators == null) throw ArgumentNullException("generators");
			if (!generators.Any()) throw CollectionEmptyException("generators");
			if (indexGenerator == null) throw ArgumentNullException("indexGenerator");

			return new ChooseGenerator<TSource>(generators, indexGenerator);
		}
		*/

		/// <summary>
		/// Make a generator that randomly generates elements from a list.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="list">The source list.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException">list</exception>
		/// <exception cref="System.ArgumentException">List must have at least one element;list</exception>
		public static IGenerator<TSource> ChooseUniformRandom<TSource>(IList<TSource> list)
		{
			if (list == null) throw ArgumentNullException("list");
			if (!list.Any()) throw CollectionEmptyException("list");

			return Choose(list, UniformRandomInt(list.Count));
		}

		/// <summary>
		/// Make a generator that randomly generates elements from a list. Can be seeded.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="list">The source list.</param>
		/// <param name="seed">The seed of the random number generator to use.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException">list</exception>
		/// <exception cref="System.ArgumentException">List must have at least one element;list</exception>
		public static IGenerator<TSource> ChooseUniformRandom<TSource>(IList<TSource> list, int seed)
		{
			if (list == null) throw ArgumentNullException("list");
			if (!list.Any()) throw CollectionEmptyException("list");

			return Choose(list, UniformRandomInt(list.Count, seed));
		}

		/// <summary>
		/// Makes a generator that selects a random generator from a given element to generate an element from.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="list">The list of generators to choose from.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>list</c> is $(null).</exception>
		/// <exception cref="System.ArgumentException"><c>list</c> is empty or has null elements.
		/// </exception>
		public static IGenerator<TSource> ChooseUniformRandom<TSource>(IList<IGenerator<TSource>> list)
		{
			if (list == null) throw ArgumentNullException("list");
			if (!list.Any()) throw CollectionEmptyException("list");
			if (list.ContainsNullElements()) throw ContainsNullElementsException("list");
			
			return Choose(list, UniformRandomInt(list.Count));
		}

		/// <summary>
		/// Chooses the from the given generators selected uniform randomly.
		/// </summary>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		[Obsolete("Use an appropriate overload instead.")]
		//This is made obsolete because we cannot provide a seeded version
		//and keep the parameter order consistent. (The seed is always at the end).
		public static IGenerator<TSource> ChooseUniformRandom<TSource>(params IGenerator<TSource>[] list)
		{
			if (list == null) throw ArgumentNullException("list");
			if (!list.Any()) throw CollectionEmptyException("list");
			if (list.ContainsNullElements()) throw ContainsNullElementsException("list");

			return Choose(list, UniformRandomInt(list.Length));
		}

		/// <summary>
		/// Chooses the random.
		/// </summary>
		/// <typeparam name="TSource">The type of the t source.</typeparam>
		/// <param name="list">The list.</param>
		/// <param name="seed">The seed.</param>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		/// <exception cref="System.ArgumentNullException"><c>list</c> is $(null).</exception>
		/// <exception cref="System.ArgumentException"><c>list</c> is empty or has null elements.</exception>
		public static IGenerator<TSource> ChooseUniformRandom<TSource>(IList<IGenerator<TSource>> list, int seed)
		{
			if (list == null) throw ArgumentNullException("list");
			if (!list.Any()) throw CollectionEmptyException("list");
			if (ContainsNullElements(list)) throw ContainsNullElementsException("list");
			
			return Choose(list, UniformRandomInt(list.Count, seed));
		}

		/// <summary>
		/// Makes a generator that interpolates between values of a given generator.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="sampleCount">The sample count per cycle.</param>
		/// <param name="interpolater">The interpolater function. This function takes three arguments: the first
		/// two are the left and right endpoints, and the third is a fraction between 0 and 1. For typical interpolation, the
		/// function must return the left endpoint if this fraction is 0, and the right endpoint if the fraction is 1.</param>
		/// <returns>A new generator.</returns>
		/// <remarks>
		/// The expression <c>(x, y, t) => x*(1 - t) + y*t)</c> is standard linear interpolation.
		/// </remarks>
		/// <example>
		/// <code>
		/// var baseGenerator = Generator.Count(2); //Generates 0 1 0 1 0 1...
		/// var interpolatedGenerator = 
		///		baseGenerator.Interpolate(2, (x, y, t) => x*(1 - t) + y*t); //Generates 0 0.5f 1 0.5f 0 0.5f....
		/// </code>
		/// </example>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is $(null).</exception>
		/// <exception cref="ArgumentOutOfRangeException"><c>sampleCount</c> not positive.</exception>
		/// <exception cref="System.ArgumentNullException"><c>interpolater</c> is $(null).</exception>
		public static IGenerator<TSource> Interpolate<TSource>(
			this IGenerator<TSource> generator,
			int sampleCount,
			Func<TSource, TSource, float, TSource> interpolater)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (sampleCount <= 0) throw ArgumentNotPositiveException("sampleCount");
			if (interpolater == null) throw ArgumentNullException("interpolater");

			var window = generator
				.Window(2)
				.RepeatEach(sampleCount);

			var openSawTooth = OpenSawTooth(sampleCount);

			return Combine(window, openSawTooth, (w, t) => interpolater(w[0], w[1], t));
		}

		/// <summary>
		/// Makes a generator that interpolates between values of a given generator.
		/// </summary>
		/// <see cref="Interpolate{TSource}(IGenerator{TSource},int,Func{TSource,TSource,float,TSource})"/>
		public static IGenerator<TSource> Interpolate<TSource>(
			this IGenerator<TSource> generator,
			IGenerator<int> sampleCount,
			Func<TSource, TSource, float, TSource> interpolater)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (sampleCount == null) throw ArgumentNullException("sampleCount");
			if (interpolater == null) throw ArgumentNullException("interpolater");

			var window = generator
				.Window(2)
				.RepeatEach(sampleCount);

			var openSawTooth = OpenSawTooth(sampleCount);

			return Combine(window, openSawTooth, (w, t) => interpolater(w[0], w[1], t));
		}

		/// <summary>
		/// Interpolates a sequence, but applies dithering.
		/// </summary>
		/// <remarks>For example, if the sequence is a binary sequence 1 0 1..., the result is 
		/// a dithered sequence, something like 1 1 1 1 0 1 1 0 1 0 1 0 0 1 0 0 0 0</remarks>
		public static IGenerator<TSource> InterpolateDither<TSource>(
			this IGenerator<TSource> generator,
			IGenerator<int> sampleCount)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (sampleCount == null) throw ArgumentNullException("sampleCount");
			
			var window = generator
				.Window(2)
				.RepeatEach(sampleCount);

			var openSawTooth = OpenSawTooth(sampleCount)
				.Dither(2, new[] {0.5f, 0.3f, 0.2f});

			return Combine(window, openSawTooth, (w, t) => w[t]);
		}

		/// <summary>
		/// Makes a generator that applies a function on the elements it generates.
		/// </summary>
		/// <typeparam name="TSource">The type of the elements to generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="action">The action to apply to generated elements.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is $(null).</exception>
		/// <exception cref="System.ArgumentNullException"><c>action</c> is $(null).</exception>
		/// <example>
		/// The following will generate a generator that generates 
		/// 0 1 2 3 0 1 2 ... and print the values to the console. 
		/// <code>
		///  var generator = Generator.Count(4).Apply((x) => {Debug.Log(x);});
		/// </code>
		/// 
		/// The following will generate a monster, and sets its properties based on the 
		/// player's current level:
		/// <code>
		/// var monsterGenerator = Generator
		///		.Constant(monsterTemplate)
		///		.Apply(m => m.SetProperties(GetPlayerLevel());
		/// </code>
		/// </example>
		public static IGenerator<TSource> Apply<TSource>(
			this IGenerator<TSource> generator, Action<TSource> action)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (action == null) throw ArgumentNullException("action");

			return generator.Select(item =>
			{
				action(item);
				return item;
			});
		}

		/// <summary>
		/// Makes a generator that interleaves the elements of the specified generators.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="generator">The first generator.</param>
		/// <param name="generators">The other generators.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is $(null)</exception>
		/// <exception cref="ArgumentException">Any of <c>generators</c> is <b>null</b>.</exception>
		public static IGenerator<TSource> Interleave<TSource>(IGenerator<TSource> generator, params IGenerator<TSource>[] generators)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (generators.ContainsNullElements()) throw ContainsNullElementsException("generators");

			return Interleave(
				new List<IGenerator<TSource>> {generator}
					.Concat(generators)
					.ToList());
		}

		/// <summary>
		/// Makes a generator that interleaves the elements of the specified generators.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="generators">The source generators.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generators</c> is <b>null</b>.</exception>
		/// <exception cref="ArgumentException"><c>generators</c> is empty.</exception>
		/// <exception cref="ArgumentException">Any of <c>generators</c> is <b>null</b>.</exception>
		public static IGenerator<TSource> Interleave<TSource>(IList<IGenerator<TSource>> generators)
		{
			if (generators == null) throw ArgumentNullException("generators");
			if (!generators.Any()) throw CollectionEmptyException("generators");
			if (generators.ContainsNullElements()) throw ContainsNullElementsException("generators");
			
			int generatorCount = generators.Count;
			var choiceGenerator = Count(generatorCount);

			return Choose(generators, choiceGenerator);
		}

		/// <summary>
		/// Pads the specified generator with elements from a given list.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="padding">The padding.</param>
		/// <returns>IGenerator&lt;TSource&gt;.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>padding</c> is <b>null</b>.</exception>
		/// <example>
		/// <code>
		/// var paddedGenerator = Generator.Count(4).Pad(new List(){7, 8});
		/// //will generate 7 8 0 1 2 3 0 1 2 3...
		/// </code>
		/// </example>
		public static IGenerator<TSource> Pad<TSource>(
			this IGenerator<TSource> generator, 
			IEnumerable<TSource> padding)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (padding == null) throw ArgumentNullException("padding");
			
			return new PadGenerator<TSource>(padding, generator);
		}

		/// <summary>
		/// Pads the specified generator with a constant element repeated a specified number of times.
		/// </summary>
		/// <typeparam name="TSource">The type of elements to generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="padding">The padding value.</param>
		/// <param name="padCount">The number of values to pad.</param>
		/// <returns>A new generator.</returns>
		/// <example>
		/// <code>
		/// var generator = Generator.Count(4).Pad(0, 3);
		/// //will generate 0 0 0 0 1 2 0 1 2 ...
		/// </code>
		/// </example>
		public static IGenerator<TSource> Pad<TSource>(
			this IGenerator<TSource> generator, 
			TSource padding, 
			int padCount)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (padCount <= 0) throw ArgumentNotPositiveException("padCount");
			
			return new PadGenerator<TSource>(Enumerable.Repeat(padding, padCount), generator);
		}

		/// <summary>
		/// Makes a generator that repeatedly takes and skips over elements from a given generator. 
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="takeCount">The number of elements to take each cycle.</param>
		/// <param name="skipCount">The number of elements to skip each cycle.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is <b>null</b>.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><c>takeCount</c> is not larger than 0.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><c>skipCount</c> is negative.</exception>
		/// <example> The following generator will generate 0 1 2 4 5 6 8 9 10...
		/// <code>
		/// var generator = Generator
		///		.Count(100)
		///		.TakeAndSkip(3, 1);
		/// </code>
		/// </example>
		public static IGenerator<TSource> TakeAndSkip<TSource>(
			this IGenerator<TSource> generator, 
			int takeCount, 
			int skipCount)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (takeCount <= 0) throw ArgumentNotPositiveException("takeCount");
			if (skipCount < 0) throw ArgumentNegativeException("skipCount");
			
			return generator
				.Group(takeCount + skipCount)
				.SelectMany(group => group.Take(takeCount));
		}

		/// <summary>
		/// Makes a generator that repeatedly skips over and takes elements from a given generator. 
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="skipCount">The number of elements to skip each cycle.</param>
		/// <param name="takeCount">The number of elements to take each cycle.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is <b>null</b>.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><c>takeCount</c> is not larger than 0.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><c>skipCount</c> is negative.</exception>
		/// <example> The following generator will generate 0 1 2 4 5 6 8 9 10...
		/// <code>
		/// var generator = Generator
		///		.Count(100)
		///		.TakeAndSkip(3, 1);
		/// </code>
		/// </example>
		public static IGenerator<TSource> SkipAndTake<TSource>(
			this IGenerator<TSource> generator,
			int skipCount,
			int takeCount
			)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (takeCount <= 0) throw ArgumentNotPositiveException("takeCount");
			if (skipCount < 0) throw ArgumentNegativeException("skipCount");

			return generator
				.Skip(skipCount)
				.TakeAndSkip(takeCount, skipCount);
		}

		/// <summary>
		/// Makes a generator that skips over the specified number of elements from the source generator.
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="count">The number of elements to skip.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is <b>null</b>.</exception>
		/// <exception cref="ArgumentOutOfRangeException"><c>count</c> is negative.</exception>
		/// <example>The following generator will generate 3 4 0 1 2 3 4 0 ...
		/// <code>var generator = Generator.Count(5).Skip(3);
		/// </code></example>
		public static IGenerator<TSource> Skip<TSource>(
			this IGenerator<TSource> generator, 
			int count)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (count < 0) throw ArgumentNegativeException("count");
			
			var clonedGenerator = generator.CloneAndRestart();

			clonedGenerator.MoveNext(count);

			return clonedGenerator;
		}

		/// <summary>
		/// Makes a generator that will generate elements by casting the elements of a source
		/// generator.
		/// </summary>
		/// <typeparam name="TResult">The type of elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<TResult> Cast<TResult>(this IGenerator generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			return new CastGenerator<TResult>(generator);
		}

		/// <summary>
		/// Makes a generator that will generate elements of a source generator that is
		/// of the given type.
		/// </summary>
		/// <typeparam name="TResult">The type of the elements the generator must generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <returns>A new generator.</returns>
		public static IGenerator<TResult> OfType<TResult>(this IGenerator generator)
			where TResult : class
		{
			if (generator == null) throw ArgumentNullException("generator");

			return new OfTypeGenerator<TResult>(generator);
		}

		/// <summary>
		/// Makes a generator that generates a running aggregate of the source generator.
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generator.</typeparam>
		/// <typeparam name="TResult">The type of elements to generate.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="aggregator">The aggregator function.</param>
		/// <param name="initialValue">The initial value.</param>
		/// <returns>A new generator.</returns>
		/// <remarks>The resulting generator will generate the following sequence:
		/// <c>result0 = aggregator(initialValue, generator[0])</c>
		/// <c>result1 = aggregator(result0, generator[1])</c>
		/// <c>result2 = aggregator(result1, generator[2])</c>
		/// </remarks>
		/// <example> The following will generate the maximum element generated by
		/// source so far:
		/// <code>var generator = source.Aggregate((x, y) = Max(x, y));</code>
		/// For example, if source generates 0 1 2 0 1 2..., then generator will 
		/// generate 0 1 2 2 2 2...
		/// </example>
		public static IGenerator<TResult> Aggregate<TSource, TResult>(
			this IGenerator<TSource> generator,
			Func<TResult, TSource, TResult> aggregator,
			TResult initialValue)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (aggregator == null) throw ArgumentNullException("aggregator");

			return new AggregateGenerator<TSource, TResult>(generator, aggregator, initialValue);
		}

		/// <summary>
		/// Makes a generator that generates a running aggregate of the source generator.
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="aggregator">The aggregator.</param>
		/// <param name="initialValue">The initial value.</param>
		/// <returns>A new generator.</returns>
		/// <remarks>
		/// The resulting generator will generate the following sequence:
		/// <c>result0 = aggregator(initialValue, generator[0])</c>
		/// <c>result1 = aggregator(result0, generator[1])</c>
		/// <c>result2 = aggregator(result1, generator[2])</c>
		/// </remarks>
		public static IGenerator<TSource> Aggregate<TSource>(
			this IGenerator<TSource> generator,
			Func<TSource, TSource, TSource> aggregator,
			TSource initialValue)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (aggregator == null) throw ArgumentNullException("aggregator");

			return new AggregateGenerator<TSource, TSource>(generator, aggregator, initialValue);
		}

		/// <summary>
		/// Makes a generator that generates a running aggregate of the source generator.
		/// </summary>
		/// <typeparam name="TSource">The type of elements of the source generator.</typeparam>
		/// <param name="generator">The source generator.</param>
		/// <param name="aggregator">The aggregator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>generator</c> is <b>null</b>.</exception>
		/// <exception cref="System.ArgumentNullException"><c>aggregator</c> is <b>null</b>.</exception>
		/// <remarks>This overload uses the first item as the first element to generate.
		/// The resulting generator will generate the following sequence:
		/// <c>result0 = generator[0]</c>
		/// <c>result1 = aggregator(result0, generator[1])</c>
		/// <c>result2 = aggregator(result1, generator[2])</c>
		/// </remarks>
		public static IGenerator<TSource> Aggregate<TSource>(
			this IGenerator<TSource> generator,
			Func<TSource, TSource, TSource> aggregator)
		{
			if (generator == null) throw ArgumentNullException("generator");
			if (aggregator == null) throw ArgumentNullException("aggregator");

			return new AggregateGenerator<TSource>(generator, aggregator);
		}

		/// <summary>
		/// Makes a generator that will generate partial sums of a given generator.
		/// </summary>
		/// <param name="generator">The generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>source</c> is <b>null</b></exception>
		/// <example>The following generator will generate 0f, 1f, 2f, 3f, 4f, 5f...
		/// <code>
		/// var generator = Generator.Constant(1f).Sum();
		/// </code>
		/// </example>
		public static IGenerator<float> Sum(this IGenerator<float> generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			return generator.Aggregate((x, y) => x + y);
		}

		/// <summary>
		/// Makes a generator that will generate partial sums of a given generator.
		/// </summary>
		/// <param name="generator">The generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>source</c> is <b>null</b></exception>
		/// <example>The following generator will generate 0, 1, 2, 3, 4, 5...
		/// <code>
		/// var generator = Generator.Constant(1).Sum();
		/// </code>
		/// </example>
		public static IGenerator<int> Sum(this IGenerator<int> generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			return generator.Aggregate((x, y) => x + y);
		}

		/// <summary>
		/// Makes a generator the will generate the average of elements generated by another generator.
		/// </summary>
		/// <param name="generator">The generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>source</c> is <b>null</b></exception>
		/// <example>
		/// The following generator will generate 0, 0.5f, 0.33f, 0.5f, 0.4f, ...
		/// <code>var generator = Generator.Count(2).Average()</code>
		/// </example>
		public static IGenerator<float> Average(this IGenerator<float> generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			var countGenerator = Count(int.MaxValue).Skip(1); //will eventually overflow
			var sumGenerator = generator.Sum();

			return Combine(sumGenerator, countGenerator, (sum, count) => sum/count);
		}

		/// <summary>
		/// Makes a generator the will generate the average of elements generated by another generator.
		/// </summary>
		/// <param name="generator">The generator.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>source</c> is <b>null</b></exception>
		/// <example>
		/// The following generator will generate 4, 4, 4, 4, .... 
		/// <code>var generator = Generator.Constant(4).Average()</code>
		/// </example> 
		public static IGenerator<int> Average(this IGenerator<int> generator)
		{
			if (generator == null) throw ArgumentNullException("generator");

			var countGenerator = Count(int.MaxValue).Skip(1); //will eventually overflow
			var sumGenerator = generator.Sum();

			return Combine(sumGenerator, countGenerator, (sum, count) => sum / count);
		}

		/// <summary>
		/// Takes the source generator's output, and generate a dithered sequence of integers
		/// in the range 0 to levels - 1. Uses error diffusion.
		/// </summary>
		/// <param name="source">The source.</param>
		/// <param name="levels">The levels.</param>
		/// <param name="errorFactors">The error factors.</param>
		/// <returns>IGenerator&lt;System.Int32&gt;.</returns>
		public static IGenerator<int> Dither(this IGenerator<float> source, int levels, IEnumerable<float> errorFactors)
		{
			return new DitherGenerator(source, levels, errorFactors);
		} 

		/// <summary>
		/// Generates elements from the source generator until a condition is met,
		/// then generate elements from a second generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="source">The source.</param>
		/// <param name="predicate">The predicate.</param>
		/// <param name="newGenerator">The new generator.</param>
		/// <returns>A new generator</returns>
		/// <exception cref="System.ArgumentNullException"><c>source</c> is <b>null</b></exception>
		/// <exception cref="System.ArgumentNullException"><c>predicate</c> is <b>null</b></exception>
		/// <exception cref="System.ArgumentNullException"><c>newGenerator</c> is <b>null</b></exception>
		public static IGenerator<TSource> SwitchWhen<TSource>(
			this IGenerator<TSource> source,
			Func<TSource, bool> predicate,
			IGenerator<TSource> newGenerator)
		{
			if (source == null) throw ArgumentNullException("source");
			if (predicate == null) throw ArgumentNullException("predicate");
			if (newGenerator == source) throw ArgumentNullException("newGenerator");

			var sourceCopy = source.CloneAndRestart(); //otherwise we affect the results of source after this method is called
			var first = sourceCopy.NextWhile(x => !predicate(x)).Concat(sourceCopy.Next(1));

			return newGenerator.Pad(first);
		}

		/// <summary>
		/// Generates elements from a source generator for 
		/// the given number of steps, then switches to a second generator.
		/// </summary>
		/// <typeparam name="TSource">The type of the source generator.</typeparam>
		/// <param name="source">The source generator that will be used before the switch.</param>
		/// <param name="steps">The number of steps before switching.</param>
		/// <param name="newGenerator">The new generator that will be used after the switch.</param>
		/// <returns>A new generator.</returns>
		/// <exception cref="System.ArgumentNullException"><c>source</c> is <b>null</b></exception>
		/// <exception cref="System.ArgumentNullException"><c>newGenerator</c> is <b>null</b></exception>
		public static IGenerator<TSource> SwitchAfter<TSource>(
			this IGenerator<TSource> source, 
			int steps, 
			IGenerator<TSource> newGenerator)
		{
			if (source == null) throw ArgumentNullException("source");
			if (newGenerator == source) throw ArgumentNullException("newGenerator");

			var selection = Constant(false).Pad(true, steps);

			return Combine(selection, source, newGenerator, (choice, x, y) => choice ? x : y);
		}

		public static IGenerator<bool> Poisson(int minRadius, int maxRadius)
		{
			return new PoissonGenerator(minRadius, maxRadius);
		}
		#endregion

		#region Exception Builders
		private static ArgumentNullException ArgumentNullException(string paramName)
		{
			return new ArgumentNullException(paramName);
		}

		private static ArgumentException CollectionEmptyException(string paramName)
		{
			return new ArgumentException("Collection is empty", paramName);
		}

		private static ArgumentException ContainsNullElementsException(string paramName)
		{
			return new ArgumentException("Contains null elements", paramName);
		}

		private static ArgumentException ArgumentNotPositiveException(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName, "Argument is not positive");
		}

		private static ArgumentException ArgumentNotBiggerThan(int n, string paramName)
		{
			return new ArgumentOutOfRangeException(paramName, "Argument is not bigger than " + n);
		}

		private static ArgumentException ArgumentNegativeException(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName, "Argument is not positive");
		}

		private static ArgumentOutOfRangeException ArgumentNotBetween0And1Exception(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName, "Argument not between 0 and 1");
		}

		private static bool ContainsNullElements<T>(this IEnumerable<T> list)
			where T : class
		{
			return list.Any(g => g == null);
		}

		private static bool Between0And1(float value)
		{
			return value >= 0 && value <= 1;
		}
		#endregion

		#region Helper Methods
		private static int GetRandomSeed()
		{
			return SeedGenerator.Next();
		}

		private static IEnumerable<float> BoxMullerTransform(
			float mean,
			float standardDeviation,
			float u,
			float v)
		{
			float amplitude = Mathf.Sqrt(-2 * Mathf.Log(u));
			float phase = 2 * Mathf.PI * v;

			yield return standardDeviation * amplitude * Mathf.Cos(phase) + mean;
			yield return standardDeviation * amplitude * Mathf.Sin(phase) + mean;
		}




		#endregion

		#region Helper Classes
		/// <summary>
		/// This class provides a convenient base class to base an implementation of IGenerator
		/// on.
		/// </summary>
		/// <typeparam name="TResult">The type of elements this generator generates.</typeparam>
		/// <seealso cref="IGenerator{TResult}" />
		public abstract class AbstractGenerator<TResult> : IGenerator<TResult>
		{
			object IGenerator.Current
			{
				get { return Current; }
			}

			public abstract TResult Current { get; }

			public abstract void MoveNext();

			public abstract IGenerator<TResult> CloneAndRestart();

			IGenerator IGenerator.CloneAndRestart()
			{
				return CloneAndRestart();
			}
		}

		/// <summary>
		/// A generator that generates a state given a Markov Chain state transition.
		/// </summary>
		private sealed class MarkovChainIntGenerator : AbstractGenerator<int>
		{
			#region Private Fields

			private int current;
			private readonly int initialValue;
			private readonly IGenerator<int>[] generators;
			
			#endregion

			#region Constructors

			private MarkovChainIntGenerator(IEnumerable<IGenerator<int>> generators, int initialValue)
			{
				this.generators = generators.Select(g => g.CloneAndRestart()).ToArray();

				this.initialValue = initialValue;
				current = initialValue;
			}

			/// <summary>Constructs a new MarkovChain2IntGenerator
			/// </summary>
			/// <param name="transitionTable">The conditional frequencies for the elements to generate,
			/// where frequencies[m][n] is the relative prob of generating n given m was generated 
			/// the last time </param>
			/// <param name="random">The random generator to use.</param>
			public MarkovChainIntGenerator(float[,] transitionTable, IGenerator<float> random) :
				this(transitionTable, random, SelectInitialValue(transitionTable, random))
			{
				initialValue = SelectInitialValue(transitionTable, random);
			}

			/// <summary>Constructs a new MarkovChain2IntGenerator
			/// </summary>
			/// <param name="transitionTable">The conditional frequencies for the elements to generate,
			/// where frequencies[m][n] is the relative prob of generating n given m was generated 
			/// the last time </param>
			/// <param name="random">The random generator to use.</param>
			/// <param name="initialValue">The initial value for this markov chain generator.</param>
			public MarkovChainIntGenerator(float[,] transitionTable, IGenerator<float> random, int initialValue)
			{
				int symbolCount = transitionTable.GetLength(0);

				generators = new IGenerator<int>[symbolCount];

				for (int i = 0; i < symbolCount; i++)
				{
					generators[i] = new FrequencyIntGenerator(GetRow(transitionTable, i), random);
				}

				this.initialValue = initialValue;
                current = initialValue;
			}

			private static float[] GetRow(float[,] table, int i)
			{
				int elementCount = table.GetLength(0);
				float[] row = new float[elementCount];

				for (int j = 0; j < elementCount; j++)
				{
					row[j] = table[i, j];
				}

				return row;
			}

			private static int SelectInitialValue(float[,] transitionTable, IGenerator<float> random)
			{
				int symbolCount = transitionTable.GetLength(0);

				var initialFrequencies = new float[symbolCount];

				for (int i = 0; i < symbolCount; i++)
				{
					for (int j = 0; j < symbolCount; j++)
					{
						initialFrequencies[j] += transitionTable[i,j];
					}
				}

				var initialGenerator = new FrequencyIntGenerator(initialFrequencies, random);
				return initialGenerator.Next();
			}
			#endregion

			public override int Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				current = generators[current].Next();
			}

			public override IGenerator<int> CloneAndRestart()
			{
				return new MarkovChainIntGenerator(generators, initialValue);
			}
		}

		/// <summary>
		/// A generator that generates integers given an arbitrary distribution.
		/// </summary>
		private sealed class FrequencyIntGenerator : AbstractGenerator<int>
		{
			/*
				Implementation Notes.

				This implementation is explained here:
				http://code-spot.co.za/2009/04/28/generating-random-integers-with-arbitrary-probabilities/

				The algorithm is based on n buckets. Each bucket represents
				to integers, and holds a value that "decides" for a given bucket and some random number
				which of the two integers to produce. The two index arrays are hold the two numbers for 
				the buckets, so that bucket[i] will either produce index0[i] or index1[i]. The particular 
				bucket to use is chosen randomly.

				The algorithm for generating integers 0..n-1 is based on n buckets. First, we randomly 
				select which bucket to use. Each bucket, bucket[i], is associated with two integers, index0[i]
				and index1[i], and holds a discrimator value. For a given bucket, if another random value
				falls below the discrimator, the algorithm produces index0[i], otherwise index1[i].

				The discrimators and index arrays are chosen so that the probability of generating
				a particular integer matches that of the given (relative) probabilities.
			*/
			#region Private Fields

			private readonly float[] buckets;
			private readonly int[] indices0; 
			private readonly int[] indices1;  
			private readonly IGenerator<float> randomGenerator;

			private int currentElement;
			#endregion

			#region Constructors

			private FrequencyIntGenerator(IGenerator<float> randomGenerator,
				float[] buckets,
				int[] indices0,
				int[] indices1)
			{
				this.buckets = buckets;
				this.indices0 = indices0;
				this.indices1 = indices1;
				this.randomGenerator = randomGenerator.CloneAndRestart();

				MoveNext();
			}

			/// <summary>
			/// Constructs a new FrequencyIntGenerator object. The given elements and frequencies
			/// together describe a piecewise linear distribution.
			/// </summary>
			/// <param name="relativeFrequencies">The (relative) frequency to generate integers at. The size of this
			/// sequence determines which frequencies are being generated. If the size is n, then integers from 0
			/// to n - 1 are generated.</param>
			/// <param name="randomGenerator">The random generator to use.</param>
			/// <exception cref="System.ArgumentException"><c>relativeFrequencies</c> is empty</exception>
			/// <exception cref="System.ArgumentException">Sum of values in <c>relativeFrequencies</c> is 0</exception>
			/// <exception cref="System.ArgumentException">No value in <c>relativeFrequencies</c> can be negative</exception>
			
			public FrequencyIntGenerator(
				IEnumerable<float> relativeFrequencies, 
				IGenerator<float> randomGenerator)
			{
				
				float[] frequencies = relativeFrequencies as float[] ?? relativeFrequencies.ToArray();

				if (frequencies.Length == 0) throw CollectionEmptyException("frequencies");
				
				if (frequencies.Length == 1)
				{
					if (frequencies[0] <= 0)
					{
						throw new ArgumentException("Sum of frequencies cannot be 0", "relativeFrequencies");
					}

					buckets = new[] { 1f };
					indices0 = new[] { 0 };
					indices1 = new[] { 0 };

					this.randomGenerator = randomGenerator.CloneAndRestart();

					return;
				}
				
				float sum = frequencies.Sum();

				if (sum <= 0)
				{
					throw new ArgumentException("Sum of frequencies cannot be 0", "relativeFrequencies");
				}

				if (frequencies.Any(x => x < 0))
				{
					throw new ArgumentException("Frequencies must be non-negative", "relativeFrequencies");
				}
				
				float[] absoluteProbabilities = frequencies.Select(x => x / sum * frequencies.Length).ToArray();

				buckets = new float[absoluteProbabilities.Length];
				indices0 = Enumerable.Range(0, absoluteProbabilities.Length).ToArray();
				indices0 = indices0.OrderBy(i => absoluteProbabilities[i]).ToArray();

				int leftIndex = 0;
				int rightIndex = absoluteProbabilities.Length - 1;

				indices1 = new int[indices0.Length];
				
				while (leftIndex <= rightIndex)
				{
					buckets[leftIndex] = absoluteProbabilities[indices0[leftIndex]];

					absoluteProbabilities[indices0[leftIndex]] = 0;
					absoluteProbabilities[indices0[rightIndex]] -= (1 - buckets[leftIndex]);

					indices1[leftIndex] = indices0[rightIndex];

					leftIndex++;
					indices0 = Enumerable.Take(indices0, leftIndex)
						.Concat(
							indices0.Skip(leftIndex).OrderBy(i => absoluteProbabilities[i]))
						.ToArray();

				}
				
				this.randomGenerator = randomGenerator.CloneAndRestart();

				MoveNext();
			}
			#endregion

			#region Public Methods

			public override void MoveNext()
			{
				if (buckets != null)
				{
					//Note, this is a way to generate a random int and float from just one random number
					float randomBase = randomGenerator.Next()*buckets.Length;
					int derivedRandomInt = Mathf.FloorToInt(randomBase);
					float derivedRandomFloat = randomBase - derivedRandomInt;

					currentElement = derivedRandomFloat < buckets[derivedRandomInt] ? indices0[derivedRandomInt] : indices1[derivedRandomInt];
				}
			}
			
			public override int Current
			{
				get { return currentElement; }
			}

			public override IGenerator<int> CloneAndRestart()
			{
				return new FrequencyIntGenerator(randomGenerator, buckets, indices0, indices1);
			}

			#endregion
		}

		private sealed class DitherGenerator : AbstractGenerator<int>
		{
			private int current;
			private readonly IGenerator<float> source;
			private readonly int levels;
			private readonly float[] errorBuffer;
			private readonly float[] errorFactors;
			private int frontIndex;

			public override int Current
			{
				get { return current; }
			}

			public DitherGenerator(IGenerator<float> source, int levels, IEnumerable<float> errorFactors)
			{
				this.source = source.CloneAndRestart();
				this.levels = levels;
				this.errorFactors = errorFactors.ToArray();
				errorBuffer = new float[this.errorFactors.Length];
				frontIndex = 0;
				MoveNext();
			}

			public override void MoveNext()
			{
				float sourceValue = source.Next();
				float scaledValue = sourceValue * levels;
				float error = errorBuffer[frontIndex];
				current = Mathf.Clamp(Mathf.FloorToInt(scaledValue + error), 0, levels - 1);
				float newError = scaledValue + error - current;
				errorBuffer[frontIndex] = 0;
				frontIndex++;

				if (frontIndex >= errorBuffer.Length)
				{
					frontIndex = 0;
				}

				for (int i = 0; i < errorBuffer.Length; i++)
				{
					errorBuffer[(frontIndex + i) % errorBuffer.Length] += errorFactors[i] * newError;
				}
			}

			public override IGenerator<int> CloneAndRestart()
			{
				return new DitherGenerator(source, levels, errorFactors);
			}
		}

		private sealed class ConstantGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly TSource item;

			public ConstantGenerator(TSource item)
			{
				this.item = item;
			}

			public override TSource Current
			{
				get
				{
					return item;
				}
			}

			public override void MoveNext()
			{
				// Nothing to do
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new ConstantGenerator<TSource>(item);
			}
		}

		private sealed class FuncGenerator<TResult> : AbstractGenerator<TResult>
		{
			private readonly Func<TResult> generator;
			private TResult current;

			public override TResult Current
			{
				get { return current; }
			}

			public FuncGenerator(Func<TResult> generator)
			{
				this.generator = generator;

				MoveNext();
			}

			public override void MoveNext()
			{
				current = generator();
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new FuncGenerator<TResult>(generator);
			}
		}

		private sealed class SelectGenerator<TSource, TResult> : AbstractGenerator<TResult>
		{
			private readonly IGenerator<TSource> generator;
			private readonly Func<TSource, TResult> func;

			public SelectGenerator(IGenerator<TSource> generator, Func<TSource, TResult> func)
			{
				this.generator = generator.CloneAndRestart();
				this.func = func;
			}

			public override void MoveNext()
			{
				generator.MoveNext();
			}

			public override TResult Current
			{
				get { return func(generator.Current); }
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new SelectGenerator<TSource, TResult>(generator, func);
			}
		}

		private sealed class SelectManyGenerator<TSource, TResult> : AbstractGenerator<TResult>
		{
			private readonly IGenerator<TSource> generator;
			private readonly Func<TSource, IEnumerable<TResult>> selectMany;
			private IEnumerator<TResult> currentIterator;

			public SelectManyGenerator(IGenerator<TSource> generator, Func<TSource, IEnumerable<TResult>> selectMany)
			{
				this.generator = generator;
				this.selectMany = selectMany;

				currentIterator = selectMany(generator.Current).GetEnumerator();
				currentIterator.MoveNext();
			}

			public override TResult Current
			{
				get { return currentIterator.Current; }
			}

			public override void MoveNext()
			{
				if (!currentIterator.MoveNext())
				{
					generator.MoveNext();
					currentIterator = selectMany(generator.Current).GetEnumerator();
					currentIterator.MoveNext();
				}
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new SelectManyGenerator<TSource, TResult>(generator, selectMany);
			}
		}

		
		private sealed class WhereGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly IGenerator<TSource> generator;
			private readonly IGenerator<bool> predicate;
			private readonly bool throwAfterMaxIterations;
			private readonly int maxIterations;

			public WhereGenerator(IGenerator<TSource> generator, IGenerator<bool> predicate)
				:this(generator, predicate, false, -1)
			{ }

			public WhereGenerator(IGenerator<TSource> generator, IGenerator<bool> predicate, int maxIterations)
				: this(generator, predicate, true, maxIterations)
			{ }

			private WhereGenerator(
				IGenerator<TSource> generator,
				IGenerator<bool> predicate,
				bool throwAfterMaxIterations,
				int maxIterations)
			{
				if (throwAfterMaxIterations && maxIterations <= 1)
				{
					throw new ArgumentOutOfRangeException("maxIterations", "Argument must be positive");
				}

				this.generator = generator.CloneAndRestart();
				this.predicate = predicate.CloneAndRestart();
				this.throwAfterMaxIterations = throwAfterMaxIterations;
				this.maxIterations = maxIterations;
			}

			public override void MoveNext()
			{
				generator.MoveNext();
				predicate.MoveNext();

				var count = 0;

				while (!predicate.Current)
				{
					if (throwAfterMaxIterations && count > maxIterations)
					{
						throw new TimeoutException(string.Format("Could not generate an element in {0} iterations", maxIterations));
					}

					generator.MoveNext();
					predicate.MoveNext();

					count++;
				}
			}

			public override TSource Current
			{
				get { return generator.Current; }
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new WhereGenerator<TSource>(
					generator, 
					predicate, 
					throwAfterMaxIterations, 
					maxIterations);
			}
		}

		/*
		private sealed class WhereGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly IGenerator<TSource> generator;
			private readonly IGenerator<bool> predicate;

			public WhereGenerator(IGenerator<TSource> generator, IGenerator<bool> predicate)
			{
				this.generator = generator.CloneAndRestart();
				this.predicate = predicate.CloneAndRestart();
			}

			public override void MoveNext()
			{
				predicate.MoveNext();
				generator.MoveNext();

				while (!predicate.Current)
				{
					predicate.MoveNext();
					generator.MoveNext();
				}
			}

			public override TSource Current
			{
				get { return generator.Current; }
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new WhereGenerator<TSource>(generator, predicate);
			}
		}*/

		private sealed class RepeatGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly IEnumerable<TSource> list;
			private readonly IEnumerator<TSource> iterator;

			public RepeatGenerator(IEnumerable<TSource> list)
			{
				this.list = list;
				iterator = this.list.GetEnumerator();

				iterator.MoveNext(); //assume the list has at least one value
			}

			public override TSource Current
			{
				get { return iterator.Current; }
			}

			public override void MoveNext()
			{
				if (!iterator.MoveNext()) //At end
				{
					iterator.Reset();
					iterator.MoveNext();
				}
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new RepeatGenerator<TSource>(list);
			}
		}

		private sealed class RepeatEachGenerator<TSource> : AbstractGenerator<TSource>
		{
			private int index;
			private readonly IGenerator<TSource> generator;
			private readonly IGenerator<int> repeatCount;

			public RepeatEachGenerator(IGenerator<TSource> generator, IGenerator<int> repeatCount)
			{
				this.generator = generator.CloneAndRestart();
				this.repeatCount = repeatCount;
				index = 0;
			}

			public override TSource Current
			{
				get { return generator.Current; }
			}

			public override void MoveNext()
			{
				index++;

				if (index >= repeatCount.Current)
				{
					generator.MoveNext();
					repeatCount.MoveNext();
					index = 0;
				}
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new RepeatEachGenerator<TSource>(generator, repeatCount);
			}
		}

		private sealed class WindowGenerator<TSource> : AbstractGenerator<TSource[]>
		{
			private readonly IGenerator<TSource> generator;
			private readonly Queue<TSource> queue;

			public WindowGenerator(IGenerator<TSource> generator, int n)
			{
				this.generator = generator.CloneAndRestart();

				var initialItems = this.generator.Next(n);

				queue = new Queue<TSource>();

				foreach (var item in initialItems)
				{
					queue.Enqueue(item);
				}
			}

			public override TSource[] Current
			{
				get { return queue.ToArray(); }
			}

			public override void MoveNext()
			{
				var nextItem = generator.Next();

				queue.Enqueue(nextItem);
				queue.Dequeue();
			}

			public override IGenerator<TSource[]> CloneAndRestart()
			{
				return new WindowGenerator<TSource>(generator, queue.Count);
			}
		}

		private sealed class ChooseGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly IList<IGenerator<TSource>> generators;
			private readonly IGenerator<int> choice;

			public override TSource Current
			{
				get { return generators[choice.Current].Current; }
			}

			public ChooseGenerator(IEnumerable<IGenerator<TSource>> generators, IGenerator<int> choice)
			{
				this.generators = generators.Select(g => g.CloneAndRestart()).ToList();
				this.choice = choice.CloneAndRestart();
			}

			public override void MoveNext()
			{
				choice.MoveNext();
				generators[choice.Current].MoveNext();
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new ChooseGenerator<TSource>(generators, choice);
			}
		}

		private sealed class CountGenerator : AbstractGenerator<int>
		{
			private int current;
			private readonly int upperLimitExcluded;

			public CountGenerator(int upperLimitExcluded)
			{
				current = 0;
				this.upperLimitExcluded = upperLimitExcluded;
			}

			public override int Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				current++;

				if (current >= upperLimitExcluded)
				{
					current = 0;
				}
			}

			public override IGenerator<int> CloneAndRestart()
			{
				return new CountGenerator(upperLimitExcluded);
			}
		}

		private sealed class CombineGenerator<TSource, TResult> : AbstractGenerator<TResult>
		{
			private readonly IEnumerable<IGenerator<TSource>> generators;
			private readonly Func<IList<TSource>, TResult> func;

			public CombineGenerator(IEnumerable<IGenerator<TSource>> generators, Func<IList<TSource>, TResult> func)
			{
				this.generators = generators.Select(g => g.CloneAndRestart()).ToList();
				this.func = func;
			}

			public override TResult Current
			{
				get { return func(generators.Select(g => g.Current).ToList()); }
			}

			public override void MoveNext()
			{
				foreach (var generator in generators)
				{
					generator.MoveNext();
				}
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new CombineGenerator<TSource, TResult>(generators, func);
			}
		}

		private sealed class CombineGenerator<T1, T2, TSource> : AbstractGenerator<TSource>
		{
			private readonly IGenerator<T1> generator1;
			private readonly IGenerator<T2> generator2;
			private readonly Func<T1, T2, TSource> func;

			public CombineGenerator(
				IGenerator<T1> generator1,
				IGenerator<T2> generator2,
				Func<T1, T2, TSource> func)
			{
				this.generator1 = generator1.CloneAndRestart();
				this.generator2 = generator2.CloneAndRestart();
				this.func = func;
			}

			public override TSource Current
			{
				get { return func(generator1.Current, generator2.Current); }
			}

			public override void MoveNext()
			{
				generator1.MoveNext();
				generator2.MoveNext();
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new CombineGenerator<T1, T2, TSource>(generator1, generator2, func);
			}
		}

		private sealed class CombineGenerator<T1, T2, T3, TSource> : AbstractGenerator<TSource>
		{
			private readonly IGenerator<T1> generator1;
			private readonly IGenerator<T2> generator2;
			private readonly IGenerator<T3> generator3;
			private readonly Func<T1, T2, T3, TSource> func;

			public CombineGenerator(
				IGenerator<T1> generator1,
				IGenerator<T2> generator2,
				IGenerator<T3> generator3,
				Func<T1, T2, T3, TSource> func)
			{
				this.generator1 = generator1.CloneAndRestart();
				this.generator2 = generator2.CloneAndRestart();
				this.generator3 = generator3.CloneAndRestart();

				this.func = func;
			}

			public override TSource Current
			{
				get { return func(generator1.Current, generator2.Current, generator3.Current); }
			}

			public override void MoveNext()
			{
				generator1.MoveNext();
				generator2.MoveNext();
				generator3.MoveNext();
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new CombineGenerator<T1, T2, T3, TSource>(generator1, generator2, generator3, func);
			}
		}

		private sealed class CombineGenerator<T1, T2, T3, T4, TSource> : AbstractGenerator<TSource>
		{
			private readonly IGenerator<T1> generator1;
			private readonly IGenerator<T2> generator2;
			private readonly IGenerator<T3> generator3;
			private readonly IGenerator<T4> generator4;
			private readonly Func<T1, T2, T3, T4, TSource> func;

			public CombineGenerator(
				IGenerator<T1> generator1,
				IGenerator<T2> generator2,
				IGenerator<T3> generator3,
				IGenerator<T4> generator4,
				Func<T1, T2, T3, T4, TSource> func)
			{
				this.generator1 = generator1.CloneAndRestart();
				this.generator2 = generator2.CloneAndRestart();
				this.generator3 = generator3.CloneAndRestart();
				this.generator4 = generator4.CloneAndRestart();

				this.func = func;
			}

			public override TSource Current
			{
				get
				{
					return func(
						generator1.Current,
						generator2.Current,
						generator3.Current,
						generator4.Current);
				}
			}

			public override void MoveNext()
			{
				generator1.MoveNext();
				generator2.MoveNext();
				generator3.MoveNext();
				generator4.MoveNext();
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new CombineGenerator<T1, T2, T3, T4, TSource>(generator1, generator2, generator3, generator4, func);
			}
		}

		private sealed class UniformRandomIntGenerator : AbstractGenerator<int>
		{
			private readonly int upperLimitExcluded;
			private readonly Random random;
			private int current;
			private int? seed;

			public UniformRandomIntGenerator(int upperLimitExcluded)
			{
				this.upperLimitExcluded = upperLimitExcluded;
				random = new Random(GetRandomSeed());

				MoveNext();
			}

			public UniformRandomIntGenerator(int upperLimitExcluded, int seed)
			{
				this.seed = seed;
				this.upperLimitExcluded = upperLimitExcluded;
				random = new Random(seed);

				MoveNext();
			}

			public override int Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				current = random.Next(upperLimitExcluded);
			}

			public override IGenerator<int> CloneAndRestart()
			{
				return seed.HasValue 
					? new UniformRandomIntGenerator(upperLimitExcluded, seed.Value) 
					: new UniformRandomIntGenerator(upperLimitExcluded);
			}
		}

		private sealed class UniformRandomFloatGenerator : AbstractGenerator<float>
		{
			private readonly Random random;
			private float current;
			private int? seed;

			public UniformRandomFloatGenerator()
			{
				random = new Random(GetRandomSeed());

				MoveNext();
			}

			public UniformRandomFloatGenerator(int seed)
			{
				this.seed = seed;
				random = new Random(seed);

				MoveNext();
			}
			
			public override float Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				current = (float)random.NextDouble();
			}

			public override IGenerator<float> CloneAndRestart()
			{
				return seed.HasValue
					? new UniformRandomFloatGenerator(seed.Value)
					: new UniformRandomFloatGenerator();
			}
		}

		private sealed class IterateGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly TSource initialValue;
			private readonly Func<TSource, TSource> iterator;
			private TSource current;

			public IterateGenerator(TSource initialValue, Func<TSource, TSource> iterator)
			{
				this.initialValue = initialValue;
				current = initialValue;
				this.iterator = iterator;
			}

			public override TSource Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				current = iterator(current);
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new IterateGenerator<TSource>(initialValue, iterator);
			}
		}

		//TODO check parms
		private sealed class IterateGenerator1<TSource, TSource2> : AbstractGenerator<TSource>
		{
			private readonly TSource initialValue;
			private readonly Func<TSource, TSource2, TSource> iterator;
			private readonly IGenerator<TSource2> parm2; 
			private TSource current;

			public IterateGenerator1(
				TSource initialValue, 
				IGenerator<TSource2> parm2, 
				Func<TSource, TSource2, TSource> iterator)
			{
				this.initialValue = initialValue;
				current = initialValue;
				this.iterator = iterator;
				this.parm2 = parm2.CloneAndRestart();
			}

			public override TSource Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				current = iterator(current, parm2.Next());
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new IterateGenerator1<TSource, TSource2>(initialValue, parm2, iterator);
			}
		}

		private sealed class IterateNGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly Queue<TSource> queue;
			private readonly IEnumerable<TSource> initialValues; 

			private readonly Func<IList<TSource>, TSource> iterator;

			private TSource previous;
			private TSource current;

			public IterateNGenerator(
				IEnumerable<TSource> initialValues,
				Func<IList<TSource>, TSource> iterator)
			{
				this.initialValues = initialValues;
				this.iterator = iterator;

				queue = new Queue<TSource>();

				foreach (var value in this.initialValues)
				{
					queue.Enqueue(value);
				}
			}

			public override TSource Current
			{
				get { return queue.Peek(); }
			}

			public override void MoveNext()
			{
				var newValue = iterator(queue.ToArray());

				queue.Enqueue(newValue);
				queue.Dequeue();
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new IterateNGenerator<TSource>(initialValues, iterator);
			}
		}

		private sealed class GroupGenerator<TSource> : AbstractGenerator<IList<TSource>>
		{
			private readonly IGenerator<TSource> generator;
			private readonly IGenerator<int> count;
			private TSource[] currentGroup;

			public GroupGenerator(IGenerator<TSource> generator, IGenerator<int> count)
			{
				this.generator = generator;
				this.count = count;
				
				int nextCount = count.Next();
				currentGroup = new TSource[nextCount];

				for (int i = 0; i < nextCount; i++)
				{
					currentGroup[i] = generator.Next();
				}
			}

			public override IList<TSource> Current
			{
				get { return currentGroup; }
			}

			public override void MoveNext()
			{
				int nextCount = count.Next();

				currentGroup = new TSource[nextCount];

				for (int i = 0; i < nextCount; i++)
				{
					currentGroup[i] = generator.Next();
				}
			}

			public override IGenerator<IList<TSource>> CloneAndRestart()
			{
				return new GroupGenerator<TSource>(generator, count);
			}
		}

		private sealed class PadGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly IEnumerable<TSource> padding;
			private readonly IGenerator<TSource> generator;
			private readonly IEnumerator<TSource> enumerator;
			private bool donePadding;

			public override TSource Current
			{
				get
				{
					return donePadding ? generator.Current : enumerator.Current;
				}
			}

			public PadGenerator(IEnumerable<TSource> padding, IGenerator<TSource> generator)
			{
				this.padding = padding;
				this.generator = generator.CloneAndRestart();

				enumerator = this.padding.GetEnumerator();
				donePadding = !enumerator.MoveNext();
			}

			public override void MoveNext()
			{
				if (donePadding)
				{
					generator.MoveNext();
				}
				else
				{
					donePadding = !enumerator.MoveNext();
				}
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new PadGenerator<TSource>(padding, generator);
			}
		}

		private class CastGenerator<TResult> : AbstractGenerator<TResult>
		{
			private readonly IGenerator generator;

			public CastGenerator(IGenerator generator)
			{
				this.generator = generator.CloneAndRestart();
			}

			public override TResult Current
			{
				get { return (TResult)generator.Current; }
			}

			public override void MoveNext()
			{
				generator.MoveNext();
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new CastGenerator<TResult>(generator);
			}
		}

		private sealed class OfTypeGenerator<TResult> : AbstractGenerator<TResult> 
			where TResult:class
		{
			private readonly IGenerator generator;

			public OfTypeGenerator(IGenerator generator)
			{
				this.generator = generator.CloneAndRestart();

				while (!(this.generator.Current is TResult))
				{
					this.generator.MoveNext();
				}
			}

			public override TResult Current
			{
				get
				{
					return (TResult) generator.Current;
				}
			}

			public override void MoveNext()
			{
				generator.MoveNext();

				while (!(generator.Current is TResult))
				{
					generator.MoveNext();
				}
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new OfTypeGenerator<TResult>(generator);
			}
		}

		private sealed class AggregateGenerator<TSource> : AbstractGenerator<TSource>
		{
			private readonly IGenerator<TSource> generator;
			private readonly Func<TSource, TSource, TSource> aggregator;
			private TSource current;
			  
			public AggregateGenerator(
				IGenerator<TSource> generator, 
				Func<TSource, TSource, TSource> aggregator)
			{
				this.generator = generator.CloneAndRestart();
				this.aggregator = aggregator;
				
				//TODO: Is this semantics expected?
				var first = this.generator.Next();
				var second = this.generator.Next();

				current = this.aggregator(first, second);
			}

			public override TSource Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				var next = generator.Next();
				current = aggregator(current, next);
			}

			public override IGenerator<TSource> CloneAndRestart()
			{
				return new AggregateGenerator<TSource>(generator, aggregator);
			}
		}

		private sealed class AggregateGenerator<TSource, TResult> : AbstractGenerator<TResult>
		{
			private readonly IGenerator<TSource> generator;
			private readonly Func<TResult, TSource, TResult> aggregator;
			private TResult current;
			private readonly TResult initialValue;

			public AggregateGenerator(
				IGenerator<TSource> generator,
				Func<TResult, TSource, TResult> aggregator,
				TResult initialValue)
			{
				Debug.Log(generator.Next());
				this.generator = generator.CloneAndRestart();
				this.aggregator = aggregator;
				this.initialValue = initialValue;

				var first = initialValue;
				var second = this.generator.Next();

				current = this.aggregator(first, second);
			}

			public override TResult Current
			{
				get { return current; }
			}

			public override void MoveNext()
			{
				var next = generator.Next();
				current = aggregator(current, next);
			}

			public override IGenerator<TResult> CloneAndRestart()
			{
				return new AggregateGenerator<TSource, TResult>(generator, aggregator, initialValue);
			}
		}

		public class PoissonGenerator : AbstractGenerator<bool>
		{
			private int minRadius;
			public int maxRadius;
			private bool current;
			private IGenerator<int> radiusGenerator;
			private int currentIndex;

			public override bool Current
			{
				get
				{
					return current;
				}
			}

			public PoissonGenerator(int minRadius, int maxRadius)
			{
				this.minRadius = minRadius;
				this.maxRadius = maxRadius;

				radiusGenerator = 
					UniformRandomInt(maxRadius - minRadius)
					.Select(x => x + minRadius);

				MoveNext();
			}

			public override IGenerator<bool> CloneAndRestart()
			{
				return new PoissonGenerator(minRadius, maxRadius);
			}

			public override void MoveNext()
			{
				current = (currentIndex == radiusGenerator.Current);

				currentIndex++;

				if(currentIndex > radiusGenerator.Current)
				{
					radiusGenerator.MoveNext();
					currentIndex = 0;
				}
				
			}
		}
		#endregion
	}
}
